const mongoose = require('mongoose');
const dotenv = require('dotenv');
// So let's check what's going on here, and so yeah I see the problem which is that we actually require the app file after our environment variables are read from the config file. And so it needs to be the other way around.
dotenv.config({ path: './config.env' });
const app = require('./app');

// ENVIRONMENT VARIABLES : Now this is not exactly about Express, it really has to do with node JS development in general. So node JS, or Express apps, can run in different environments. And the most important ones are the development environment and the production environment. That's because depending on the environment, we might use different databases for example, or we might turn login on or off, or we might turn debugging on or off, or really all kinds of different settings that might change depending on the development that we're in.

// So again the most important ones are the development and the production environment. But there are other environments that bigger teams might use. So this type of setting that I just mentioned, like different databases or login turned on or off, that will be based on environment variables. Now by default, Express sets the environment to development . So remember that everything that is not related to Express we're gonna do it outside of the app.JS file. So we only use this one here to configuring our application. So we only use this one in order to configure everything that has to do with the Express application. But the environment variables are really outside the scope of Express.
// console.log(app.get('env'))

// So in summary, environment variables are global variables that are used to define the environment in which a node app is running. So this one is set by Express, but node JS itself actually sets a lot of environments. So these ones are located at process.env. For example my home folder or my login name you see the script that we use to start this process so really a bunch of stuff that for some reason node JS internally needs. Now these variables, they come from the process core module and we're set at the moment that the process started. And as you see, we didn't have to require the process module right. It is simply available everywhere automatically. Now in Express, many packages depend on a special variable called NODE_ENV . So it's a variable that's kind of a convention which should define whether we're in development or in production mode okay. However Express does not really define this variable, and so we have to do that manually. And there are multiple ways in which we can do it.
// console.log(process.env);

// Now it's not really practical to always define all of these variables in the command where we start the application. So imagine we had 10 environmental variables and it would be not really practical to having to write them out all here inside of this command. And so instead what we do is to create a configuration file. So let me go ahead and create config.env.

// Now how do we actually connect this .env file with our node application? So we need some way of reading these variables from this file and then saving them as environment variables. Because right now this is just a text file and node JS has no way of knowing that these variables are in here. And so for that the standard is kind of using a npm package called .env. So npm install.env, all right, then let's go over to our server and actually require that module. And down here we can simply use this dotenv variable called config on it and then in there we just have to pass an object to specify the path where our configuration file is located. So path, config dotenv. And so what this command will now do is to read our variables from the file and save them into node JS environment variables.

// Now you might be wondering why we actually have access to this environment variable here when we didn't really define them in this file but in server.js. And the answer to that is that the reading of the variables from the file which happens here to the node process only needs to happen once. It's then in the process and the process is of course the same no matter in what file we are. So we're always in the same process and the environment variables are on the process. And so the process that is running, so where our application is running is always the same and so this is available to us in every single file in the project.
// dotenv.config({ path: './config.env' });

// console.log(process.env);

// DATABASE connection : So, now it's finally time to connect the MongoDB database that we created with our Express application. And, the first step in doing that is to actually get our connection string from Atlas. So, just like we did before when we connected the database to Compass and to the Mongo Shell, we need to get our connection string in order to connect the application to this hosted database. Anyway, just click here on Connect Your Application and then this here is our connection string. Just make sure that you select Node.js here actually because the string might change based on that.

// And so, let's now go ahead and copy our connection string and then back in our application, we create it as an environment variable here in our config file. So, I already have DATABASE_PASSWORD. Let's create DATABASE now. Now, two things about this connection string. First, here in this place, we need to put in our password. Then, second, this here is actually our host, so basically the place where the database is hosted and then /test. Now, this test here is the name of the database that we want to connect to. And, in our case, we already created the natours database. And so, it's very important that here, in this connection string, we replace this test with the name of our database.

// Next up, we need to install a MongoDB driver, so basically a software that allows our Node code to access and interact with a MongoDB database. And, there are a couple of different MongoDB drivers, but we're gonna use the one that I would say is the most popular one, which is called Mongoose, which adds a couple of features to the more native MongoDB driver. Let's go now to server.js here, which, remember, is kind of the file where we do all of the setup of our application. For example, the environment variables or the imports or Express application. And, we also start the server down here. And so, this is also the file where we're gonna configure MongoDB. So, let's start by requiring our mongoose package here. And so, now we have access to the mongoose variable and on there, we simply call the connect method. Now, into this connect method, we need to, of course, pass in our database connection string. But, remember that, in there, we still have the password. So, basically this password placeholder here. And so, before we pass in the string, we need to actually replace it. So, replace it with the real password that we have here.

// So, in here, the first argument is actually that connection string, so DB. And then, second, we pass in an object with some options and these are just some options that we need to specify in order to deal with some deprecation warnings. Now, this connect method here is gonna return a promise and so let's actually handle that promise by using then(). And, this promise here actually gets access to a connection object.

const DB = process.env.DATABASE.replace(
  '<PASSWORD>',
  process.env.DATABASE_PASSWORD,
);

// Connecting to local Database : just replace DB with your local database connection string but here we are connected with databse atlas which is hosted on cloud.
mongoose
  .connect(DB, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => console.log(`Database Connected successful`));

// 4] SERVER : So, simple as that. And later on we will actually have other stuff in this file that is not related to express, but still related to our application. So stuff like database configurations, or some error handling stuff, or environment variables, all of that stuff will live in this server.js, which is kind of our entry point.
const port = process.env.PORT || 8000;
const server = app.listen(port, () => {
  console.log(`App running on port ${port}...`);
});

// Unhandled Rejections : So at this point, we have successfully handled errors in our express application by passing operational asynchronous errors down into a global error handling middleware. This, then sends relevant error messages back to the client depending on the type of error that occurred, right? However, there might also occur errors outside of express and a good example for that in our current application is the mongodb database connection. So imagine that the database is down for some reason or for some reason, we cannot log in. And in that case, there are errors that we have to handle as well. But they didn't occur inside of our express application and so, of course, our error handler that we implemented will not catch this errors, right? here we have an unhandled promise rejection. And so that is actually the topic of this video. So an unhandled promise rejection means that somewhere in our code, there is a promise that got rejected. But that rejection has not been handled anywhere, all right? And down here, you also see a deprecation warning which says that in the future unhandled rejections will simply exit the node program that's running, which may not always be what you want, okay? So let's fix this problem and get rid of this unhandled promise rejection. Now, in this simple example here, it would be actually quite easy to handle that rejection, right? All we'll have to do would to come here to this piece of code where our connection is actually done and then, add a catch handler there, right?

// And so now, you get error which is of course, the result of this log here, but of course, we get no unhandled promise rejection, again, because we actually handled it here, all right? So this would work, of course, but I really want to show you how to globally handle unhandled rejected promises, because in a bigger application, it can become a bit more difficult to always keep track of all the promises that might become rejected at some point, okay? And so at some point, you might have some unhandled promise rejection somewhere and so let me show you how to deal with that globally basically. And so remember how in one of the first section of the course, we talked about events and event listeners, right? And so now, it's time to actually use that knowledge. So each time that there is an unhandled rejection somewhere in our application, the process object will emit an object called unhandled rejection and so we can subscribe to that event just like this. So process.on, remember, and then the name of the event, unhandled rejection, and then the callback function here receives an error.

// So these are kind of some defaults that we have on all errors in node.js, all right? Okay, and after saving, we already, down here get the name of the error and also the error message. So bad authentication which is because, of course, we have the wrong password. And so right now, the unhandled promise rejection is now actually handled. And of course, not just the one from this failed connection but any other promise rejection that we might not catch somewhere in the application is handled here in this final, let's call it safety net, all right? So we always have to assume that we as programmers are gonna make errors. And so it's always best to have a central place like this to handle all promise rejections like a last safety net, all right? Now, if we really have like some problem with the database connection, like we have in this example, then our application is not gonna work at all. And so all we can really do here is to shut down our application, all right? So to shutdown the application, we use process.exit. And we actually already used that before in that script where we imported all the data into the database from the JSON file, remember? So process.exit and then in here, we can actually pass a code. And the code zero stands for a success and one stands for uncaught exception. And so that's the one that's usually used here, all right? So usually, you will always see it like this.

// And so now, you see that the app actually crashed. And so that's because of this process.exit here, all right? Now, there is just one problem with the way we implemented it right now and that is, that the way we implement it here so just process.exit is a very abrupt way of ending the program because this will just immediately abort all the requests that are currently still running or pending and so that might not be a good idea, okay? And so usually, what we do is to shutdown gracefully where we first close the server and only then, we shut down the application, okay? And so the result of calling app.listen is a server and to now, on that server, we can then say server.close which will, as the name says, close the server and then after that's done, it will run this callback function that we passed into it and so it's only here, where we then shut down the server, okay? And so by doing this, by doing server.close, we give the server, basically time to finish all the request that are still pending or being handled at the time, and only after that, the server is then basically killed, all right?
process.on('unhandledRejection', (err) => {
  console.log('UNHANDLED REJECTION 💥 Shutting down...');
  console.log(err.name, err.message);
  server.close(() => {
    process.exit(0);
  });
});

// Uncaught Exceptions : But what exactly are uncaught exceptions? Well, all errors, or let's also call them bugs, that occur in our synchronous code but are not handled anywhere are called uncaught exceptions. And like before, so just like with the unhandled rejections, we also have a way of handling uncaught exceptions. So let's simply pretend that we're trying to console.log something that doesn't exist. And so right away, we get this error here, x is not defined, and then by default, we get this entire stack trace here printed to the console. All right. And now, to fix this, this is very similar to doing the unhandled rejections. So again, we're listening to an event, this time it's called uncaughtException. And of course it needs to be in quotes. And then just like before, we pass in our callback function. Okay. And now actually what we're doing here is very similar to what we did here. So we wanna lock the error to the console so that it then shows up in the logs in our server, okay? So, giving us a way of then fixing the problem. And then we want to gracefully shut down the server.

// And that's actually all there is to catching uncaught exceptions. Now while here in the unhandled rejection, crashing the application like we did here is optional, when there is an uncaught exception, we really, really need to crash our application because after there was an uncaught exception, the entire node process is in a so-called unclean state, all right? And so to fix that, the process need to terminate and then to be restarted, all right? And again, in production, we should then have a tool in place which will restart the application after crashing. And many hosting services already do that out of the box, all right? So, completely automatically without us having to do anything.

// Now actually this handler here should be at the very top of our code, okay? Or at least before any other code is really executed. Because watch what happens if I move this line of code here before this handler. So if I put it here, for example, and then give it a save, then you actually see that our handler does not catch this exception, so this error here, right? And so that's because only here at the end we actually start listening for an uncaught exception. But in this case here, the uncaught exception happens before we even listen to that event. And so therefore, we have no way of catching it, right? And so we should ideally put it here, right at the top, again before any other code executes. Especially the one in our application.

// But if we now had this code, for example inside of app.js, let's say, it doesn't really matter, let's just say it's here, and if we now run this, well then you see that we're still catching that exception in our error handler, which before would not be the case. All right? And now just for an experiment, what do you think if we put this code right here in this middleware function? What do you think is gonna happen when we save this file now? So x is still not defined anywhere, but let's take a look at what happens when we now run this code. And so now we actually have no error. Or actually we do, but that's only because of our unhandled rejection, which is due to the fact that our password here is still wrong. So if we save that and now save it again, you should see no error at all. And indeed, we don't. And why is that? Well, it's because this middleware function here of course is only called as soon as there actually is a request, right? And so let's see what happens when we do a request. And so let's do a Get All Tours request. And, here we get a "Something went very wrong!" error message with the 500, and that's also because we are still in production mode, okay? But anyway, getting this message here, remember, means that we have a non operational error here. So basically an error that we did not create ourselves. uncaughtExceptions are synchronous and unhandledRejections are asynchronous
process.on('uncaughtException', (err) => {
  console.log('UNCAUGHT EXCEPTION 💥 Shutting down...');
  console.log(err.name, err.message);
  process.exit(1);
});
// console.log(x);
// Responding to SIGTERM Signal: So a Heroku dyno, and again a dyno is just a name that Heroku uses for basically a container in which your application is running so these dynos restart every 24 hours in order to keep your app in a healthy state. Okay? And the way that Heroku does this is by sending the so-called "sick term signal" to our note application, and the application will then basically shut down immediately. All right? Now, the problem with this is that the shut down can be very abrupt. So this can then leave requests that are currently being processed basically hanging in the air, and so that's not ideal. So basically that's what happens also when there is an unhandled rejection. So here in our server, dot JS, remember how we actually gracefully shut down the server whenever there was an unhandled rejection. All right? So now we're actually gonna do something very similar when we receive the "sick term signal".
process.on('SIGTERM', () => {
  console.log('👋SIGTERM received. Shutting down gracefully');
  server.close(() => {
    console.log('💥 Process terminated!');
  });
});
